# JNI入门

## 引子

JNI 是 java 访问 C/C++ 代码的技术手段，对于 Android 源码的分析非常重要。

## 1. C/C++ 基础

这里推荐两本书：

- 《一站式学习c语言》 宋劲杉
- 《21天学通c++(第8版)》Siddhartha Rao，21天是学不完的，不要相信书名

后面我会整理一个知识要点的思维导图，可以对照检查，查疑补缺。

## 2. JNI 上手 （静态注册）

通过 JNI 我们可以在 java 中访问 C/C++ 代码。
我们直接上手写个示例：

### 2.1  写一个HelloJNI.java去调用C代码

```java
public class HelloJNI {  // Save as HelloJNI.java
   static {
      System.loadLibrary("hello"); // Load native library hello.dll (Windows) or libhello.so (Unixes)
                                   //  at runtime
                                    // This library contains a native method called sayHello()
   }
 
   // Declare an instance native method sayHello() which receives no parameter and returns void
   private native void sayHello();
 
   // Test Driver
   public static void main(String[] args) {
      new HelloJNI().sayHello();  // Create an instance and invoke the native method
   }
}
```

### 2.2  编译Java程序 & 生成C/C++头文件 HelloJNI.h

```bash
javac -h . HelloJNI.java
```

该命令会生成一个 HelloJNI.h，这个头文件描述了我们需要实现的函数。

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloJNI */

#ifndef _Included_HelloJNI
#define _Included_HelloJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloJNI
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

- C 函数有两个参数：

  - JNIEnv：JNIEnv 内部提供了很多函数，方便我们进行 JNI 编程。

    C 代码中，JNIEnv 是指向 JNINativeInterface 结构的指针，为了访问任何一个 JNI 函数，该指针需要首先被解引用。因为 C代码中的 JNI 函数不了解当前的 JNI 环境, JNIEnv 实例应该作为第一个参数传递给每一个 JNI 函数调用调用者，调用格式如下:

    ```c
    (*env)->NewStringUTF(env,"Hello from JNI !");
    ```

    在 C++ 代码中，JNIEnv 实际上是 C++ 类实例，JNI 函数以成员函数的形式存在，因此 JNI 函数调用不要求 JNIEnv 实例作参数。在 C++ 中，完成同样功能的调用代码格式如下:

    ```c
    env->NewstringUTF ( "Hello from JNI ! ");
    ```
  - jobject:  指向 "this" 的 Java 对象
  - 如果 java 中的 native 函数是 static 的，那第二个参数是 jclass，代表了 java 中的 Class 类。
- extern "C" 告诉 C++ 编译器以 C 的方式来编译这个函数，以方便其他 C 程序访问该函数。C 和 C++ 有着不同的命名协议，因为 C++ 支持函数重载，用了不同的命名协议来处理重载的函数。在 C 中函数是通过函数名来识别的，而在 C++ 中，由于存在函数的重载问题，函数的识别方式通过函数名，函数的返回类型，函数参数列表三者组合来完成的。因此两个相同的函数，经过C，C++编绎后会产生完全不同的名字。所以，如果把一个用 C 编绎器编绎的目标代码和一个用 C++ 编绎器编绎的目标代码进行链接，就会出现链接失败的错误。
- JNIEXPORT、JNICALL 两个宏在 linux 平台的定义如下：

  ```c
  //该声明的作用是保证在本动态库中声明的方法 , 能够在其他项目中可以被调用
  #define JNIEXPORT  __attribute__ ((visibility ("default")))
  //一个空定义
  #define JNICALL
  ```

### 2.3 在 HelloJNI.c 中实现 C 程序

```c
#include "HelloJNI.h"
#include <stdio.h>
#include <jni.h>

JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject obj)
{
    return (*env)->NewStringUTF(env,"Hello from JNI !");
}
```

编译和执行（需要配置好 JAVA_HOME 环境变量）：

```bash
gcc -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libhello.so HelloJNI.c
java -Djava.library.path=. HelloJNI
```

以上使用 JNI 的方式称为静态注册，还有一种方式叫动态注册。

## 3 JNI 上手 （动态注册）

java层：
com/example/ndk/NativeTest.java

```java
package com.example.ndk;

public class NativeTest {
    static {
      System.loadLibrary("nativetest"); 
    }
    public native void init();

    public native void init(int age);

    public native boolean init(String name);

    public native void update();
}
```

C 层的实现主要有三步：

- 实现 java 层本地方法
- 构建一个 JNINativeMethod 类型的数组
- 注册本地函数

NativeTest.c :

```c
#include <jni.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

//1 实现 java 层本地方法
JNIEXPORT void JNICALL
c_init1(JNIEnv *env, jobject thiz) {
     printf("c_init1\n");
}
  
JNIEXPORT void JNICALL
c_init2(JNIEnv *env, jobject thiz, jint age) {
    printf("c_init2\n");
}
  
JNIEXPORT jboolean JNICALL
c_init3(JNIEnv *env, jobject thiz, jstring name) {
    printf("c_init3\n");
}
 
JNIEXPORT void JNICALL
c_update(JNIEnv *env, jobject thiz) {
    printf("c_update\n");
}

#ifdef __cplusplus
}
#endif


// typedef struct {
// 	//Java层native方法名称
//    const char* name;
// 	//方法签名
//    const char* signature;
// 	//native层方法指针
//    void*       fnPtr;
// } JNINativeMethod;

//2 构建 JNINativeMethod 数组
//中间的方法签名看上去有点怪异，后面我们来讲它的命名规则
static JNINativeMethod methods[] = {
        {"init", "()V", (void *)c_init1},
        {"init", "(I)V", (void *)c_init2},
        {"init", "(Ljava/lang/String;)Z", (void *)c_init3},
        {"update", "()V", (void *)c_update},
};

/**
 * 3 完成动态注册的入口函数
 *  其内容基本固定
 */ 
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = NULL;
    jint result = -1;
 
    // 获取JNI env变量
    if (vm->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
        // 失败返回-1
        return result;
    }
 
    // 获取native方法所在类
    const char* className = "com/example/ndk/NativeTest";
    jclass clazz = env->FindClass(className);
    if (clazz == NULL) {
        return result;
    }
 
    // 动态注册native方法
    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0])) < 0) {
        return result;
    }
 
    // 返回成功
    result = JNI_VERSION_1_6;
    return result;
}

```

JNINativeMethod 第二个成员变量是方法签名，它的组成规则为：

**(参数类型标识1参数类型标识2...参数类型标识n)返回值类型标识**

其中的类型标识如下图所示：

| 类型标识    | Java数据类型 |
| ----------- | ------------ |
| Z           | boolean      |
| B           | byte         |
| C           | char         |
| S           | short        |
| I           | int          |
| J           | long         |
| F           | float        |
| D           | double       |
| L包名/类名; | 各种引用类型 |
| V           | void         |

编译和执行：

```bash
cd com/example/ndk
javac NativeTest.java
#回到项目根目录
cd -
g++ -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libnativetest.so NativeTest.c
java -Djava.library.path=. com.example.ndk.NativeTest
```

## 总结

* 静态注册，[源码](https://github.com/ahaoddu/AndroidSourceLearn/tree/main/Demos/JniDemo/StaticRegister)
* 动态注册，[源码](https://github.com/ahaoddu/AndroidSourceLearn/tree/main/Demos/JniDemo/DynamicRegister)

jni 涉及的内容非常多，遇到问题可以查阅  [Java Native Interface Specification Contents](https://docs.oracle.com/en/java/javase/11/docs/specs/jni/)

## 参考资料

- [JNI 简明教程之手把手教你入门](https://blog.csdn.net/weiwei9363/article/details/97886291)
- [cross-compiling-for-android-with-the-ndk](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-android-with-the-ndk)
- [Android 官方cmake文档](https://developer.android.com/ndk/guides/cmake)
- 《Android C++高级编程》第三章
- [JNI/NDK开发指南](https://blog.csdn.net/xyang81/category_9263427.html)

## 关于我

- 我叫阿豪，目前定居成都
- 2012 年开始从事 Android 系统定制和应用开发相关的工作
- 2015 年毕业于国防科技大学，毕业后从事 Android 相关的开发和研究工作
- 2019年初开始创业，从事 Android 系统开发工作
- 如果你对 Android 系统源码感兴趣可以扫码添加我的微信，相互学习交流。

![27c7e38ee991b9d1fb42cb3bdf352a7.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/2613680/1662174041146-53015bfc-12f7-4023-9131-0a9e51fd00a2.jpeg#clientId=u0593d637-e239-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ud527bf55&margin=%5Bobject%20Object%5D&name=27c7e38ee991b9d1fb42cb3bdf352a7.jpg&originHeight=430&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42506&status=done&style=none&taskId=uf620381e-5767-4559-867e-093d91d3256&title=#crop=0&crop=0&crop=1&crop=1&id=qxLzV&originHeight=430&originWidth=430&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
