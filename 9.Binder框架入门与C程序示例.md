## 1. binder 是什么

binder 是一个 linux 驱动，用于进程间的数据交换。

进程通信就会涉及两个概念：IPC(Inter-Process Communication),  RPC(Remote Procedure Call)：

IPC：指进程间数据交换的技术手段。

RPC：指进程间的方法调用，一般基于 IPC。

binder 驱动用于进程间交换数据，属于 IPC 技术。 binder 驱动加上应用层的封装，就构成了 binder RPC 框架，使得我们能在 A 进程访问 B 进程的方法。

## 2. binder 的基本工作流程

binder 驱动：IPC 技术，用于进程间的数据交换。

如果阅读了 预备知识-驱动入门 ，应该知道，访问一个驱动和访问一个磁盘上的文件流程大体一致（驱动类型不同，访问方法有些许变化），binder 驱动的基本使用流程如下：

* open 函数打开驱动
* mmap 完成映射
* 调用 ioctl 函数发送或者接收数据
* close 函数关闭驱动

当然这里会涉及到两个进程：

![](https://gitee.com/stingerzou/pic-bed/raw/master/20220917134845.png)

这里又会引出一个问题，A 进程发送的数据 x，binder 驱动是把它发送给 b 进程还是 c 进程？

为了解决这个问题，就需要引入一个管家 manager，manager 有一个编号0，其他进程把这个编号发送给 binder 驱动，驱动就知道是要发送数据给 manager。

b 进程需要事先在 manager 这里注册登记（同样使用binder通信），登记的时候需要记录一个名字,这里假设是 hello，登记完成后，会给 b 进程一个编号，这里假设是 1。A 进程给B进程发送数据的流程就变成了下面这样：

1. 获取到 b 进程的编号 1

![](https://gitee.com/stingerzou/pic-bed/raw/master/20220917142222.png)

2. 向 b 进程发送数据

   ![img](https://gitee.com/stingerzou/pic-bed/raw/master/20220917143751.png)

ps：以上内容，为方便理解，做了简化

每次都调用 open ioctl 等函数来使用 binder 会显得异常的繁琐，接下来我们来看一下 android 各层对 binder 操作的封装。

## 3. binder c 层封装

### 3.1 对象与流程

在 c 层，涉及到了四个对象：

* client：客户端向 servicemanager 获取到服务，通过 binder 远程执行服务中的函数
* server：向 servicemanager 注册服务，等待 client 的远程调用
* servicemamager：用于管理服务
* binder驱动

ps: 在源码的 frameworks/native/cmds/servicemanager 目录下有一个示例程序 bctest.c 可用于 c 层的学习，需要注意的是在 Android-10 上，这个程序是错误的。但是对于我们学习仍有参考价值。

c 层的工作流程如下：

![img](https://gitee.com/stingerzou/pic-bed/raw/master/20220917154127.png)

接下来我们先了解 c 层对 binder 使用封装的 API，然后写一个 binder 成员示例程序。

### 3.2  C层 API

#### binder_open

```c
struct binder_state *binder_open(const char* driver, size_t mapsize)
```

binder_open 用于打开 binder 驱动，第一个参数一般固定为 "/dev/binder"，第二个参数为驱动需要开辟的用于进程通信的内核内存的大小，单位为字节。返回值是一个结构体，本文称其为 binder 句柄：

```c
struct binder_state
{
    int fd; // "/dev/binder" 对应的句柄
    void *mapped; //用户态的内存指针，该段内存与内核中的一段内存完成了 mmap 映射
    size_t mapsize; //大小
};
```

#### binder_call

```c
int binder_call(struct binder_state *bs,
                struct binder_io *msg, struct binder_io *reply,
                uint32_t target, uint32_t code)
```

binder_call 用于发起远程函数调用（调用另一个进程中的函数），bs 是 binder 句柄。binder_io 是传输数据的格式，msg 是传出的数据，reply是收到的数据，target 用于告诉 servicemanger 我要使用那个service，即指定目标进程。code 用于表示我要调用那个函数。

#### binder_loop

用于服务端或 service_manager 进入循环读数据解析数据

```c
void binder_loop(struct binder_state *bs, binder_handler func)
```

bs 是 handler 指针，binder_handler 是函数指针，是一个收到数据的回调：

```c
typedef int (*binder_handler)(struct binder_state *bs,
                              struct binder_transaction_data_secctx *txn,
                              struct binder_io *msg,
                              struct binder_io *reply);
```

bs 是binder句柄， txn，msg 是收到的数据， reply 是我们要回复给client的数据

### 3.3 示例程序

todo：（录视频？感觉文字不好描述）

1.程序的集成与调试方法

2.源码的解析

binder_server.c：

```c
int main(int argc, char **argv)
{
    struct binder_state *bs;
    uint32_t svcmgr = BINDER_SERVICE_MANAGER;
    uint32_t handle;
	int ret;

    ALOGW("BinderServer 开始启动");
  
    //打开驱动
    bs = binder_open("/dev/binder", 128*1024);
    if (!bs) {
        fprintf(stderr, "failed to open binder driver\n");
        return -1;
    }
	//添加服务
	ret = svcmgr_publish(bs, svcmgr, "hello", hello_service_handler);
    if (ret) {
        fprintf(stderr, "failed to publish hello service\n");
        return -1;
    } else {
        ALOGW("BinderServer 添加 hello service 成功");
    }
  
    ALOGW("服务器进入消息循环");
    binder_loop(bs, test_server_handler);
    ALOGW("服务器退出消息循环");
    return 0;
}
```

binder_client.c

```c

int main(int argc, char **argv)
{
    int fd;
    struct binder_state *bs;
    uint32_t svcmgr = BINDER_SERVICE_MANAGER;
	int ret;

    bs = binder_open("/dev/binder", 128*1024);
    if (!bs) {
        fprintf(stderr, "failed to open binder driver\n");
        return -1;
    }

    g_bs = bs;

	/* get service */
	g_handle = svcmgr_lookup(bs, svcmgr, "hello");
	if (!g_handle) {
        ALOGW("binder client 查找服务 hello 失败");
        return -1;
	} else {
        ALOGW("binder client 查找服务成功 handle = %d", g_handle);
    }

    //调用服务
    sayhello();

}

void sayhello(void)
{
    unsigned iodata[512/4];
    struct binder_io msg, reply;

	/* 构造binder_io */
    bio_init(&msg, iodata, sizeof(iodata), 4);
   

	/* 放入参数 */
    bio_put_uint32(&msg, 0);  // strict mode header
    bio_put_string16_x(&msg, "IHelloService");

	/* 调用binder_call */
    if (binder_call(g_bs, &msg, &reply, g_handle, HELLO_SVR_CMD_SAYHELLO))
        return ;

	/* 从reply中解析出返回值 */
    binder_done(g_bs, &msg, &reply);

}

```

详细的源码示例可以查看 https://github.com/ahaoddu/AndroidSourceLearn/tree/main/Demos/BinderCDemo

## 遇到的问题

示例代码 bctest.c 在 Android10 中添加服务，查询服务均失败。给 service_manager.c 打log发现 bctest 发送的数据格式与service_manager 在头部差了一个0，添加数据，问题解决。

## 参考资料：
