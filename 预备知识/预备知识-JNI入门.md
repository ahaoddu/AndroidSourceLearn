## 引子

JNI 是 java 访问 C/C++ 代码的技术手段，对于 Android 源码的分析非常重要。学习 jni 主要分为以下几步：

- 掌握 C/C++，建议快速过语法（利用思维导图建立好基本知识框架）+持续学习+查疑补缺
- 掌握 JNI 基本语法与流程（本文）
- 实践，JNI 只是 java 层与 c 层互相访问的接口，实践的部分更多涉及到的是 linux 系统编程

## 1. C/C++ 基础

这里推荐两本书：

- 《一站式学习c语言》 宋劲杉
- 《21天学通c++(第8版)》Siddhartha Rao，21天是学不完的，不要相信书名

后面我会整理一个知识要点的思维导图，可以对照检查，查疑补缺。

## 2. JNI 上手 （静态注册）

通过 JNI 我们可以在 java 中访问 C/C++ 代码。
我们直接上手写个示例：

### 2.1  写一个HelloJNI.java去调用C代码

```java
public class HelloJNI {  // Save as HelloJNI.java
   static {
      System.loadLibrary("hello"); // Load native library hello.dll (Windows) or libhello.so (Unixes)
                                   //  at runtime
                                    // This library contains a native method called sayHello()
   }
 
   // Declare an instance native method sayHello() which receives no parameter and returns void
   private native void sayHello();
 
   // Test Driver
   public static void main(String[] args) {
      new HelloJNI().sayHello();  // Create an instance and invoke the native method
   }
}
```

### 2.2  编译Java程序 & 生成C/C++头文件 HelloJNI.h

```bash
javac -h . HelloJNI.java
```

该命令会生成一个 HelloJNI.h，这个头文件描述了我们需要实现的函数。

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloJNI */

#ifndef _Included_HelloJNI
#define _Included_HelloJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloJNI
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

这里我们需要关注以下 3 点：

- 从 java 中的 native 方法到 C 函数，函数命名的转换规则是：Java_{package_and_classname}_{function_name}(JNI_arguments)。Java包名中的 "." 将被转换为 "_"。Java 中的 sayHello 方法被转换成了了 JNIEXPORT void JNICALL Java_HelloJNI_(JNIEnv *, jobject);
- C 函数有两个参数：

  - JNIEnv*:  指向 JNI 环境，通过它可以调用 JNI 相关的函数
  - jobject:  指向 "this" 的 Java 对象

    在这个 hello-world 示例中不需要用到这两个参数。另外，我们先忽略 JNIEXPORT 和 JNICALL 这个两个宏，知道是这么写的就行。
- extern "C" 告诉 C++ 编译器以 C 的方式来编译这个函数，以方便其他 C 程序访问该函数。C 和 C++ 有着不同的命名协议，因为 C++ 支持函数重载，用了不同的命名协议来处理重载的函数。在 C 中函数是通过函数名来识别的，而在 C++ 中，由于存在函数的重载问题，函数的识别方式通函数名，函数的返回类型，函数参数列表三者组合来完成的。因此两个相同的函数，经过C，C++编绎后会产生完全不同的名字。所以，如果把一个用 C 编绎器编绎的目标代码和一个用 C++ 编绎器编绎的目标代码进行链接，就会出现链接失败的错误。

### 2.3 在 HelloJNI.c 中实现 C 程序

```c
#include "HelloJNI.h"
#include <stdio.h>
#include <jni.h>

JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject obj)
{
    printf("hello JNI\n");
    return;
}
```

编译和执行（需要配置好 JAVA_HOME 环境变量）：

```bash
gcc -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libhello.so HelloJNI.c
java -Djava.library.path=. HelloJNI
```

以上使用 JNI 的方式称为静态注册，还有一种方式叫动态注册。

## 3 JNI 上手 （动态注册）

java层：
com/example/ndk/NativeTest.java

```java
package com.example.ndk;

public class NativeTest {
    static {
      System.loadLibrary("nativetest"); 
    }
    public native void init();

    public native void init(int age);

    public native boolean init(String name);

    public native void update();
}
```

C 层的实现主要有三步：

- 实现 java 层本地方法
- 构建一个 JNINativeMethod 类型的数组
- 注册本地函数

NativeTest.c :

```c
#include <jni.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

//1 实现 java 层本地方法
JNIEXPORT void JNICALL
c_init1(JNIEnv *env, jobject thiz) {
     printf("c_init1\n");
}
  
JNIEXPORT void JNICALL
c_init2(JNIEnv *env, jobject thiz, jint age) {
    printf("c_init2\n");
}
  
JNIEXPORT jboolean JNICALL
c_init3(JNIEnv *env, jobject thiz, jstring name) {
    printf("c_init3\n");
}
 
JNIEXPORT void JNICALL
c_update(JNIEnv *env, jobject thiz) {
    printf("c_update\n");
}

#ifdef __cplusplus
}
#endif


// typedef struct {
// 	//Java层native方法名称
//    const char* name;
// 	//方法签名
//    const char* signature;
// 	//native层方法指针
//    void*       fnPtr;
// } JNINativeMethod;

//2 构建 JNINativeMethod 数组
//中间的方法签名看上去有点怪异，后面我们来讲它的命名规则
static JNINativeMethod methods[] = {
        {"init", "()V", (void *)c_init1},
        {"init", "(I)V", (void *)c_init2},
        {"init", "(Ljava/lang/String;)Z", (void *)c_init3},
        {"update", "()V", (void *)c_update},
};

/**
 * 3 完成动态注册的入口函数
 *  其内容基本固定
 */ 
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = NULL;
    jint result = -1;
 
    // 获取JNI env变量
    if (vm->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
        // 失败返回-1
        return result;
    }
 
    // 获取native方法所在类
    const char* className = "com/example/ndk/NativeTest";
    jclass clazz = env->FindClass(className);
    if (clazz == NULL) {
        return result;
    }
 
    // 动态注册native方法
    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0])) < 0) {
        return result;
    }
 
    // 返回成功
    result = JNI_VERSION_1_6;
    return result;
}

```

JNINativeMethod 第二个成员变量是方法签名，它的组成规则为：

**(参数类型标识1参数类型标识2...参数类型标识n)返回值类型标识**

其中的类型标识如下图所示：

| 类型标识    | Java数据类型 |
| ----------- | ------------ |
| Z           | boolean      |
| B           | byte         |
| C           | char         |
| S           | short        |
| I           | int          |
| J           | long         |
| F           | float        |
| D           | double       |
| L包名/类名; | 各种引用类型 |
| V           | void         |

编译和执行：

```bash
cd com/example/ndk
javac NativeTest.java
#回到项目根目录
cd -
g++ -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libnativetest.so NativeTest.c
java -Djava.library.path=. com.example.ndk.NativeTest
```

## 3. JNI基础

### 3.1 JNI流程

native程序主要做了这么几件事：

1. 接收 JNI 类型的参数
2. 参数类型转换，JNI 类型转换为 Native 类型
3. 执行 Native 代码
4. 创建一个 JNI 类型的返回对象，将结果拷贝到这个对象并返回结果

### 3.2 JNI类型

JNI 中定义了与 Java 类型对应的 JNI 类型：

- 基本类型：jint, jbyte, jshort, jlong, jfloat, jdouble, jchar, jboolean 对应 Java 中的原始类型 int, byte, short, long, float, double, char, boolean
- 引用类型：jobject 对应 java.lang.Object。还定义了以下的子类：
  - jclass 对应 java.lang.Class
  - jstring 对应 java.lang.String
  - jthrowable 对应 java.lang.Throwable
  - jarray 对应 Java 的数组类型，有八种原始类型的数组：jintArray, jbyteArray, jshortArray, jlongArray, jfloatArray, jdoubleArray, jcharArray, jbooleanArray 和一种 object 数组 jobjectArray

### 3.3 示例

本节的示例主要展示 java 和 c 层之间数据类型的转换与方法访问，用于开发时的参考。

##### 3.3.1 原始类型

```java

//java
private native double average(int n1, int n2);

//c++
JNIEXPORT jdouble JNICALL Java_TestJNIPrimitive_average(
    JNIEnv *env, jobject obj, jint n1, jint n2)
{
    //原始类型不用做转换，直接使用
    cout << "n1 = " << n1 << ", n2 = " << n2 << endl;
    return jdouble(n1 + n2)/2.0;
}
```

##### 3.2.2 字符串

```java
//java
private native String sayHello(String msg);

//c++
JNIEXPORT jstring JNICALL Java_TestJNIString_sayHello(
    JNIEnv *env, jobject obj, jstring inJNIString)
{
    //将 java 中的 String 转换为 char*
    const char* inStr = env->GetStringUTFChars(inJNIString, NULL);
    if(NULL == inStr)
        return NULL;

    //内存清理工作
    cout << "the received string is " << inStr << endl;
    env->ReleaseStringUTFChars(inJNIString, inStr);

    string outString;
    cout << "Enter a String:";
    cin >> outString;
    // char* 转换为 string
    return env->NewStringUTF(outString.c_str());
}
```



##### 3.2.3 数组

```java
 //java
// 返回数组double[2]，其中double[0]为和，double[1]为平均数
private native double[] sumAndAverage(int[] numbers);

//c++
JNIEXPORT jdoubleArray JNICALL Java_TestJNIPrimitiveArray_sumAndAverage(
    JNIEnv *env, jobject obj, jintArray inJNIArray)
{
    //int[] -> jintArray -> jint*
    jint* inArray = env->GetIntArrayElements(inJNIArray, NULL);
    if(NULL == inArray) return NULL;
    //获取到数组长度
    jsize length = env->GetArrayLength(inJNIArray);

    jint sum = 0;
    for(int i = 0; i < length; ++i)
    {
        sum += inArray[i];
    }

    jdouble average = (jdouble)sum / length;
    //释放数组
    env->ReleaseIntArrayElements(inJNIArray, inArray, 0); // release resource

    jdouble outArray[] = {sum, average};
    jdoubleArray outJNIArray = env->NewDoubleArray(2);
    if(NULL == outJNIArray) return NULL;
    env->SetDoubleArrayRegion(outJNIArray, 0, 2, outArray);
    return outJNIArray;

}
```

##### 3.2.4 访问对象的实例变量

```java
//java
public class TestJNIInstanceVariable{
    static {
        System.loadLibrary("myjni");
    }

    private int number = 88;
    private String message = "Hello from Java";

    private native void modifyInstanceVariable();

    public static void main(String[] args){
        TestJNIInstanceVariable test = new TestJNIInstanceVariable();
        test.modifyInstanceVariable();

        System.out.println("In Java, int is " + test.number);
        System.out.println("In Java, String is " + test.message);
    }
}
```

```c
//c++
#include "TestJNIInstanceVariable.h"
#include <iostream>

using namespace std;

JNIEXPORT void JNICALL Java_TestJNIInstanceVariable_modifyInstanceVariable(
    JNIEnv *env, jobject thisObj)
{
    // Get a reference to this object's class
    jclass thisClass = env->GetObjectClass(thisObj);

    // Int
    // Get the Field ID of the instance variables "number"
    jfieldID fidNumber = env->GetFieldID(thisClass, "number", "I");
    if(NULL == fidNumber) return;

    // Get the int given the Field ID
    jint number = env->GetIntField(thisObj, fidNumber);
    cout << "In C++, the int is " << number << endl;

    // Change the variable
    number = 99;
    env->SetIntField(thisObj, fidNumber, number);

    // String
    // Get the Field ID of the instance variables "message"
    jfieldID fidMessage = env->GetFieldID(thisClass, "message", "Ljava/lang/String;");
    if(NULL == fidMessage) return;

    // Get the int given the Field ID
    jstring message =  (jstring)env->GetObjectField(thisObj, fidMessage);

    // Create a C-String with JNI String
    const char* str = env->GetStringUTFChars(message, NULL);
    if(NULL == str) return;

    cout << "In C++, the string is " << str << endl;

    // Create a new C-String and assign to the JNI string
    message = env->NewStringUTF("Hello from C++");
    if(NULL == message) return;

    env->SetObjectField(thisObj, fidMessage, message);
}

```

通过 GetFieldID 获取实例变量的字段 ID，这需要你提供变量的名称以及其字段的描述符：

| **描述符**   | **含义** |
| ------------------ | -------------- |
| I                  | int            |
| B                  | byte           |
| S                  | short          |
| J                  | long           |
| F                  | float          |
| D                  | double         |
| C                  | char           |
| Z                  | boolean        |
| [I                 | int[]          |
| Ljava/lang/String  | String         |
| [Ljava/lang/String | String[]       |

##### 3.2.5 访问类的静态变量

```java
//java
public class TestJNIStaticVariable{
    static {
        System.loadLibrary("myjni");
    }

    private static double number = 55.66;

    private native void modifyStaticVariable();

    public static void main(String args[]) {
        TestJNIStaticVariable test = new TestJNIStaticVariable();
        test.modifyStaticVariable();
        System.out.println("In Java, the double is " + number);
    }
}
```

```cpp
#include "TestJNIStaticVariable.h"
#include <iostream>
using namespace std;

JNIEXPORT void JNICALL Java_TestJNIStaticVariable_modifyStaticVariable(
    JNIEnv *env, jobject thisObj)
{
    jclass thisClass = env->GetObjectClass(thisObj);

    jfieldID fidNumber = env->GetStaticFieldID(thisClass, "number", "D");
    if(NULL == fidNumber) return;

    jdouble number = env->GetStaticDoubleField(thisClass, fidNumber);
    cout << "In C++, the double is " << number << endl;

    number = 77.88;
    env->SetStaticDoubleField(thisClass, fidNumber, number);
}
```

##### 3.2.6 回调实例方法和静态方法

```java
public class TestJNICallBackMethod{
    static {
        System.loadLibrary("myjni");
    }

    private native void nativeMethod();

    private void callback(){
        System.out.println("In Java");
    }

    private void callback(String message){
        System.out.println("In Java with " + message);
    }

    private double callbackAverage(int n1, int n2){
        return ((double)n1 + n2) / 2.0;
    }

    private static String callbackStatic(){
        return "From static Java method";
    }

    public static void main(String[] args){
        new TestJNICallBackMethod().nativeMethod();
    }
}
```

```cpp
#include "TestJNICallBackMethod.h"
#include <iostream>

using namespace std;

JNIEXPORT void JNICALL Java_TestJNICallBackMethod_nativeMethod(
    JNIEnv *env, jobject thisObj)
{
    jclass thisClass = env->GetObjectClass(thisObj);

    jmethodID midCallBack = env->GetMethodID(thisClass, "callback", "()V");
    if(NULL == midCallBack) return;
    cout << "In C++, call back Java's callback()\n";

    // Call back the method (which returns void), based on the Method ID
    env->CallVoidMethod(thisObj, midCallBack);

    jmethodID midCallBackStr = env->GetMethodID(thisClass, "callback", "(Ljava/lang/String;)V");
    if(NULL == midCallBackStr) return;
    cout << "In C++, call back Java's callback(String)\n";
    jstring message = env->NewStringUTF("Hello from C++");
    env->CallVoidMethod(thisObj, midCallBackStr, message);

    jmethodID midCallBackAverage = env->GetMethodID(thisClass, "callbackAverage", "(II)D");
    if(NULL == midCallBackAverage) return;
    jdouble average = env->CallDoubleMethod(thisObj, midCallBackAverage, 2, 3);
    cout << "In C++, the average is " << average << endl;

    jmethodID midCallBackStatic = env->GetStaticMethodID(thisClass, "callbackStatic", "()Ljava/lang/String;");
    if(NULL == midCallBackStatic) return;
    jstring resultJNIStr = (jstring)env->CallStaticObjectMethod(thisClass, midCallBackStatic);
    const char* resultStr = env->GetStringUTFChars(resultJNIStr, NULL);
    if(NULL == resultStr) return;
    cout << "In C++, the returned string is " << resultStr << endl;
    env->ReleaseStringUTFChars(resultJNIStr, resultStr);
}
```

##### 3.2.7 回调 super.xx() 方法

JNI 提供了一组 CallNonvirtual `<Type>`Method() 函数来调用在子类重写的方法（类型在 Java 中调用 super.methodName())

通过 GetMethodID() 获取方法ID
基于方法ID，调用 CallNonvirtual `<Type>`Method() 来回调父类方法
JNI 中用于调用重载的父类方法函数有：

```c
NativeType CallNonvirtual<type>Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...);
NativeType CallNonvirtual<type>MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args);
NativeType CallNonvirtual<type>MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args);
```

##### 3.2.8 在 native 中创建对象

```java
public class TestJavaConstructor{
    static {
        System.loadLibrary("myjni");
    }

    private native Integer getIntegerObject(int number);

    public static void main(String[] args){
        TestJavaConstructor obj = new TestJavaConstructor();
        System.out.println("In Java, the number is : " + obj.getIntegerObject(9999));
    }
}
```

```c
#include "TestJavaConstructor.h"
#include <iostream>
using namespace std;

JNIEXPORT jobject JNICALL Java_TestJavaConstructor_getIntegerObject
    (JNIEnv *env, jobject thisObj, jint number)
{
    jclass cls = env->FindClass("java/lang/Integer");

    jmethodID midInit = env->GetMethodID(cls, "<init>", "(I)V");
    if(NULL == midInit) return NULL;

    // Call back constructor to allocate a new instance, with an int argument
    jobject newObj = env->NewObject(cls, midInit, number);

    // Try running the toString() on this newly create object
    jmethodID midToString = env->GetMethodID(cls, "toString", "()Ljava/lang/String;");
    if (NULL == midToString) return NULL;

    jstring resultJNIStr = (jstring)env->CallObjectMethod(newObj, midToString);
    const char *resultStr = env->GetStringUTFChars(resultJNIStr, NULL);
    cout << "In C++, the number is " << resultStr << endl;

    return newObj;
}
```

JNI 中用于创建对象的函数有：

```c
jclass FindClass(JNIEnv *env, const char *name);
 
jobject NewObject(JNIEnv *env, jclass cls, jmethodID methodID, ...);
jobject NewObjectA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args);
jobject NewObjectV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
   // Constructs a new Java object. The method ID indicates which constructor method to invoke
 
jobject AllocObject(JNIEnv *env, jclass cls);
  // Allocates a new Java object without invoking any of the constructors for the object.

```

##### 3.2.9 对象数组

```java
import java.util.ArrayList;
 
public class TestJNIObjectArray {
   static {
      System.loadLibrary("myjni"); 
   }
   // Native method that receives an Integer[] and
   //  returns a Double[2] with [0] as sum and [1] as average
   private native Double[] sumAndAverage(Integer[] numbers);
 
   public static void main(String args[]) {
      Integer[] numbers = {11, 22, 32};  // auto-box
      Double[] results = new TestJNIObjectArray().sumAndAverage(numbers);
      System.out.println("In Java, the sum is " + results[0]);  // auto-unbox
      System.out.println("In Java, the average is " + results[1]);
   }
}
```

```cpp
#include "TestJNIObjectArray.h"
#include <iostream>
using namespace std;

JNIEXPORT jobjectArray JNICALL Java_TestJNIObjectArray_sumAndAverage(
    JNIEnv *env, jobject thisObj, jobjectArray inJNIArray)
{
    jclass classInteger = env->FindClass("java/lang/Integer");

    // Use Integer.intValue() to retrieve the int
    jmethodID midIntValue = env->GetMethodID(classInteger, "intValue", "()I");
    if (NULL == midIntValue) return NULL;

    jsize length = env->GetArrayLength(inJNIArray);
    jint sum = 0;
    for (int i = 0; i < length; i++) {
        jobject objInteger = env->GetObjectArrayElement(inJNIArray, i);
        if (NULL == objInteger) return NULL;
        jint value = env->CallIntMethod(objInteger, midIntValue);
        sum += value;
    }

    double average = (double)sum / length;
    cout << "In C++, the sum is " << sum << endl;
    cout << "In C++, the average is " << average << endl;

    // Get a class reference for java.lang.Double
    jclass classDouble = env->FindClass("java/lang/Double");

    // Allocate a jobjectArray of 2 java.lang.Double
    jobjectArray outJNIArray = env->NewObjectArray(2, classDouble, NULL);

    // Construct 2 Double objects by calling the constructor
    jmethodID midDoubleInit = env->GetMethodID(classDouble, "<init>", "(D)V");
    if (NULL == midDoubleInit) return NULL;
    jobject objSum = env->NewObject(classDouble, midDoubleInit, (double)sum);
    jobject objAve = env->NewObject(classDouble, midDoubleInit, average);

    // Set to the jobjectArray
    env->SetObjectArrayElement(outJNIArray, 0, objSum);
    env->SetObjectArrayElement(outJNIArray, 1, objAve);

    return outJNIArray;
}
```

JNI 中用于创建和操作对象数组的函数有：

```cpp
jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);
   // Constructs a new array holding objects in class elementClass.
   // All elements are initially set to initialElement.
 
jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index);
   // Returns an element of an Object array.
 
void SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value);
   // Sets an element of an Object array.
```

##### 3.2.10 局部和全局引用

在 native 方法中，我们经常使用 FindClass(), GetMethodID(), GetFieldID() 来获取 jclass, jmethodID 和 jfieldID。这些方法的调用成本很高，我们应该获取一次并且将其缓存以供后续使用，而不是重复执行调用，从而消除开销。

JNI 中 native 代码使用的对象引用分为两种：局部引用和全局引用：

1. 局部引用在 native 方法中创建，并在退出 native 方法时销毁。可以使用 DeleteLocalRef() 显示的使局部引用失效，以便可以进行垃圾回收。
2. 全局引用只有显示使用 DeleteGlobalRef() 才会被销毁。可以通过 NewGlobalRef() 从局部引用创建全局引用。

[
](https://blog.csdn.net/weiwei9363/article/details/97886291)

```java
public class TestJNIReference {
   static {
      System.loadLibrary("myjni"); // myjni.dll (Windows) or libmyjni.so (Unixes)
   }
 
   // A native method that returns a java.lang.Integer with the given int.
   private native Integer getIntegerObject(int number);
 
   // Another native method that also returns a java.lang.Integer with the given int.
   private native Integer anotherGetIntegerObject(int number);
 
   public static void main(String args[]) {
      TestJNIReference test = new TestJNIReference();
      System.out.println(test.getIntegerObject(1));
      System.out.println(test.getIntegerObject(2));
      System.out.println(test.anotherGetIntegerObject(11));
      System.out.println(test.anotherGetIntegerObject(12));
      System.out.println(test.getIntegerObject(3));
      System.out.println(test.anotherGetIntegerObject(13));
   }
}
```

上面的代码有两个 native 方法，它们都返回 java.lang.Integer 对象。

在 C/C++ 代码中，我们通过 FindClass() 需要获取 java.lang.Integer 的引用。然后找到 Integer 的构造函数ID。我们希望将这些都缓存起来以消除开销。

下面代码是不起作用的：

```cpp
#include <jni.h>
#include <stdio.h>
#include "TestJNIReference.h"
 
// Global Reference to the Java class "java.lang.Integer"
static jclass classInteger;
static jmethodID midIntegerInit;
 
jobject getInteger(JNIEnv *env, jobject thisObj, jint number) {
 
   // Get a class reference for java.lang.Integer if missing
   if (NULL == classInteger) {
      printf("Find java.lang.Integer\n");
      classInteger = (*env)->FindClass(env, "java/lang/Integer");
   }
   if (NULL == classInteger) return NULL;
 
   // Get the Method ID of the Integer's constructor if missing
   if (NULL == midIntegerInit) {
      printf("Get Method ID for java.lang.Integer's constructor\n");
      midIntegerInit = (*env)->GetMethodID(env, classInteger, "<init>", "(I)V");
   }
   if (NULL == midIntegerInit) return NULL;
 
   // Call back constructor to allocate a new instance, with an int argument
   jobject newObj = (*env)->NewObject(env, classInteger, midIntegerInit, number);
   printf("In C, constructed java.lang.Integer with number %d\n", number);
   return newObj;
}
 
JNIEXPORT jobject JNICALL Java_TestJNIReference_getIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}
 
JNIEXPORT jobject JNICALL Java_TestJNIReference_anotherGetIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}

```

上述代码中，我们调用 FindClass() 来获取 java.lang.Integer 的引用，并保存在全局的静态变量中。尽管如此，在下一次调用中，此引用不再有效（并且不是NULL）。这是因为FindClass（）返回一个本地引用，一旦该方法退出就会失效。

为了解决这个问题，我们需要从FindClass（）返回的局部引用创建一个全局引用。然后我们可以释放局部引用。修改后的代码如下：
[
](https://blog.csdn.net/weiwei9363/article/details/97886291)

```cpp
 // Get a class reference for java.lang.Integer if missing
   if (NULL == classInteger) {
      printf("Find java.lang.Integer\n");
      // FindClass returns a local reference
      jclass classIntegerLocal = (*env)->FindClass(env, "java/lang/Integer");
      // Create a global reference from the local reference
      classInteger = (*env)->NewGlobalRef(env, classIntegerLocal);
      // No longer need the local reference, free it!
      (*env)->DeleteLocalRef(env, classIntegerLocal);
   }
```

## 参考资料

- 
- [JNI 简明教程之手把手教你入门](https://blog.csdn.net/weiwei9363/article/details/97886291)
- [cross-compiling-for-android-with-the-ndk](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-android-with-the-ndk)
- [Android 官方cmake文档](https://developer.android.com/ndk/guides/cmake)
