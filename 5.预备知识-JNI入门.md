## 引子

JNI 是 java 访问 C/C++ 代码的技术手段，对于 Android 源码的分析非常重要。

## 1. C/C++ 基础

这里推荐两本书：

- 《一站式学习c语言》 宋劲杉
- 《21天学通c++(第8版)》Siddhartha Rao，21天是学不完的，不要相信书名

后面我会整理一个知识要点的思维导图，可以对照检查，查疑补缺。

## 2. JNI 上手 （静态注册）

通过 JNI 我们可以在 java 中访问 C/C++ 代码。
我们直接上手写个示例：

### 2.1  写一个HelloJNI.java去调用C代码

```java
public class HelloJNI {  // Save as HelloJNI.java
   static {
      System.loadLibrary("hello"); // Load native library hello.dll (Windows) or libhello.so (Unixes)
                                   //  at runtime
                                    // This library contains a native method called sayHello()
   }
 
   // Declare an instance native method sayHello() which receives no parameter and returns void
   private native void sayHello();
 
   // Test Driver
   public static void main(String[] args) {
      new HelloJNI().sayHello();  // Create an instance and invoke the native method
   }
}
```

### 2.2  编译Java程序 & 生成C/C++头文件 HelloJNI.h

```bash
javac -h . HelloJNI.java
```

该命令会生成一个 HelloJNI.h，这个头文件描述了我们需要实现的函数。

```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloJNI */

#ifndef _Included_HelloJNI
#define _Included_HelloJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloJNI
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

- C 函数有两个参数：

  - JNIEnv：JNIEnv 内部提供了很多函数，方便我们进行 JNI 编程。

    C 代码中，JNIEnv 是指向 JNINativeInterface 结构的指针，为了访问任何一个 JNI 函数，该指针需要首先被解引用。因为 C代码中的 JNI 函数不了解当前的 JNI 环境, JNIEnv 实例应该作为第一个参数传递给每一个 JNI 函数调用调用者，调用格式如下:

    ```c
    (*env)->NewStringUTF(env,"Hello from JNI !");
    ```

    在 C++ 代码中，JNIEnv 实际上是 C++ 类实例，JNI 函数以成员函数的形式存在，因此 JNI 函数调用不要求 JNIEnv 实例作参数。在 C++ 中，完成同样功能的调用代码格式如下:

    ```c
    env->NewstringUTF ( "Hello from JNI ! ");
    ```
  - jobject:  指向 "this" 的 Java 对象
  - 如果 java 中的 native 函数是 static 的，那第二个参数是 jclass，代表了 java 中的 Class 类。
- extern "C" 告诉 C++ 编译器以 C 的方式来编译这个函数，以方便其他 C 程序访问该函数。C 和 C++ 有着不同的命名协议，因为 C++ 支持函数重载，用了不同的命名协议来处理重载的函数。在 C 中函数是通过函数名来识别的，而在 C++ 中，由于存在函数的重载问题，函数的识别方式通过函数名，函数的返回类型，函数参数列表三者组合来完成的。因此两个相同的函数，经过C，C++编绎后会产生完全不同的名字。所以，如果把一个用 C 编绎器编绎的目标代码和一个用 C++ 编绎器编绎的目标代码进行链接，就会出现链接失败的错误。
- JNIEXPORT、JNICALL 两个宏在 linux 平台的定义如下：

  ```c
  //该声明的作用是保证在本动态库中声明的方法 , 能够在其他项目中可以被调用
  #define JNIEXPORT  __attribute__ ((visibility ("default")))
  //一个空定义
  #define JNICALL
  ```

### 2.3 在 HelloJNI.c 中实现 C 程序

```c
#include "HelloJNI.h"
#include <stdio.h>
#include <jni.h>

JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject obj)
{
    return (*env)->NewStringUTF(env,"Hello from JNI !");
}
```

编译和执行（需要配置好 JAVA_HOME 环境变量）：

```bash
gcc -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libhello.so HelloJNI.c
java -Djava.library.path=. HelloJNI
```

以上使用 JNI 的方式称为静态注册，还有一种方式叫动态注册。

## 3 JNI 上手 （动态注册）

java层：
com/example/ndk/NativeTest.java

```java
package com.example.ndk;

public class NativeTest {
    static {
      System.loadLibrary("nativetest"); 
    }
    public native void init();

    public native void init(int age);

    public native boolean init(String name);

    public native void update();
}
```

C 层的实现主要有三步：

- 实现 java 层本地方法
- 构建一个 JNINativeMethod 类型的数组
- 注册本地函数

NativeTest.c :

```c
#include <jni.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

//1 实现 java 层本地方法
JNIEXPORT void JNICALL
c_init1(JNIEnv *env, jobject thiz) {
     printf("c_init1\n");
}
  
JNIEXPORT void JNICALL
c_init2(JNIEnv *env, jobject thiz, jint age) {
    printf("c_init2\n");
}
  
JNIEXPORT jboolean JNICALL
c_init3(JNIEnv *env, jobject thiz, jstring name) {
    printf("c_init3\n");
}
 
JNIEXPORT void JNICALL
c_update(JNIEnv *env, jobject thiz) {
    printf("c_update\n");
}

#ifdef __cplusplus
}
#endif


// typedef struct {
// 	//Java层native方法名称
//    const char* name;
// 	//方法签名
//    const char* signature;
// 	//native层方法指针
//    void*       fnPtr;
// } JNINativeMethod;

//2 构建 JNINativeMethod 数组
//中间的方法签名看上去有点怪异，后面我们来讲它的命名规则
static JNINativeMethod methods[] = {
        {"init", "()V", (void *)c_init1},
        {"init", "(I)V", (void *)c_init2},
        {"init", "(Ljava/lang/String;)Z", (void *)c_init3},
        {"update", "()V", (void *)c_update},
};

/**
 * 3 完成动态注册的入口函数
 *  其内容基本固定
 */ 
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = NULL;
    jint result = -1;
 
    // 获取JNI env变量
    if (vm->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
        // 失败返回-1
        return result;
    }
 
    // 获取native方法所在类
    const char* className = "com/example/ndk/NativeTest";
    jclass clazz = env->FindClass(className);
    if (clazz == NULL) {
        return result;
    }
 
    // 动态注册native方法
    if (env->RegisterNatives(clazz, methods, sizeof(methods) / sizeof(methods[0])) < 0) {
        return result;
    }
 
    // 返回成功
    result = JNI_VERSION_1_6;
    return result;
}

```

JNINativeMethod 第二个成员变量是方法签名，它的组成规则为：

**(参数类型标识1参数类型标识2...参数类型标识n)返回值类型标识**

其中的类型标识如下图所示：

| 类型标识    | Java数据类型 |
| ----------- | ------------ |
| Z           | boolean      |
| B           | byte         |
| C           | char         |
| S           | short        |
| I           | int          |
| J           | long         |
| F           | float        |
| D           | double       |
| L包名/类名; | 各种引用类型 |
| V           | void         |

编译和执行：

```bash
cd com/example/ndk
javac NativeTest.java
#回到项目根目录
cd -
g++ -fpic -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/linux" -shared -o libnativetest.so NativeTest.c
java -Djava.library.path=. com.example.ndk.NativeTest
```

## 4. 数据类型

JNI 程序中涉及了三种数据类型，分别是：

* Java 类型
* JNI 类型
* C/C++ 类型

在 java 程序中我们使用的是 Java 类型，C/C++ 程序中拿到的是 JNI 类型，我们需要将其转换为 C/C++ 类型，使用 C/C++ 类型再去调用 C/C++ 层函数完成计算或IO操作等任务后，将结果再转换为 JNI 类型返回后，在 java 代码中，我们就能收到对应的 Java 类型。

我们可以在 $JAVA_HOME/inlcude/jni.h 文件中查看到 jni 中基本类型的定义：

```c
typedef unsigned char   jboolean;
typedef unsigned short  jchar;
typedef short           jshort;
typedef float           jfloat;
typedef double          jdouble;
typedef jint            jsize;
```

jbyte, jint and jlong 是和 CPU 平台(我的机器是intel 64位)相关的，定义在 jni_md.h 中：

$JAVA_HOME/include/linux/jni_md.h

```c
typedef int jint;
#ifdef _LP64
typedef long jlong;
#else
typedef long long jlong;
#endif

typedef signed char jbyte;
```

x86_64 平台梳理如下：

| Java 类型 | JNI 类型 | C/C++ 类型     |
| --------- | -------- | -------------- |
| boolean   | jboolean | unsigned char  |
| byte      | jbyte    | signed char    |
| char      | jchar    | unsigned short |
| short     | jshort   | signed short   |
| int       | jint     | int            |
| long      | jlong    | long           |
| float     | jfloat   | float          |
| double    | jdouble  | double         |

引用类型也定义在 jni.h 中，总结如下：

| java 类型           | JNI 引用类型  |
| ------------------- | ------------- |
| java.lang.Object    | jobject       |
| java.lang.String    | jstring       |
| java.lang.Class     | jclass        |
| java.lang.Throwable | jthrowable    |
| byte[]              | jbyteArray    |
| Object[]            | jobjectArray  |
| boolean[]           | jbooleanArray |
| char[]              | jcharArray    |
| short[]             | jshortArray   |
| int[]               | jintArray     |
| long[]              | jlongArray    |
| float[]             | jfloatArray   |
| double[]            | jdoubleArray  |

## 5. 数据类型转换

native 程序主要做了这么几件事：

1. 接收 JNI 类型的参数
2. 参数类型转换，JNI 类型转换为 Native 类型
3. 执行 Native 代码
4. 创建一个 JNI 类型的返回对象，将结果拷贝到这个对象并返回结果

其中很多代码都是在做类型转换的操作，下面我们来看看类型转换的示例。

### 5.1 基本类型

基本类型无需做转换，直接使用：

java 层：

```java
private native double average(int n1, int n2);
```

c/c++ 层：

```c++
JNIEXPORT jdouble JNICALL Java_HelloJNI_average(JNIEnv *env, jobject jobj, jint n1, jint n2) {
    //原始类型不用做转换，直接使用
    cout << "n1 = " << n1 << ", n2 = " << n2 << endl;
    return jdouble(n1 + n2)/2.0;
}
```

### 5.2 字符串

为了在 C/C++ 中使用 Java 字符串，需要先将 Java 字符串转换成 C 字符串。用 GetStringChars 函数可以将 Unicode 格式的 Java 字符串转换成 C 字符串，用 GetString-UTFChars 函数可以将 UTF-8 格式的 Java 字符串转换成 C 字符串。这些函数的第三个参数均为 isCopy，它让调用者确定返回的 C 字符串地址指向副本还是指向堆中的固定对象。

java 层：

```java
private native String sayHello(String msg);
```

c/c++ 层：

```c++
JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello__Ljava_lang_String_2(JNIEnv *env, jobject jobj, jstring str) {
  
    //jstring -> char*
    jboolean isCopy;
    const char* cStr = env->GetStringUTFChars(str, &isCopy);
  
    if (nullptr == cStr) {
        return nullptr;
    }

    if (JNI_TRUE == isCopy) {
        cout << "C 字符串是java字符串的一份拷贝" << endl;
    } else {
        cout << "C 字符串指向 java 层的字符串" << endl;
    }

    cout << "C/C++ 层接收到的字符串是 " << inStr << endl;
  
    //通过JNI GetStringChars 函数和 GetStringUTFChars 函数获得的C字符串在原生代码中
    //使用完之后需要正确地释放，否则将会引起内存泄露。
    env->ReleaseStringUTFChars(str, inStr);

    string outString = "Hello, JNI";
    // char* 转换为 string
    return env->NewStringUTF(outString.c_str());
}
```

### 5.3 数组

java 层：

```java
private native double[] sumAndAverage(int[] numbers);
```

c++ 层：

```cpp
JNIEXPORT jdoubleArray JNICALL Java_HelloJNI_sumAndAverage(JNIEnv *env, jobject obj, jintArray inJNIArray) {
    //类型转换 int[] -> jintArray -> jint*
    jboolean isCopy;
    jint* inArray = env->GetIntArrayElements(inJNIArray, &isCopy);

    if (JNI_TRUE == isCopy) {
        cout << "C 层的数组是 java 层数组的一份拷贝" << endl;
    } else {
        cout << "C 层的数组指向 java 层的数组" << endl;
    }

    if(nullptr == inArray) return nullptr;
    //获取到数组长度
    jsize length = env->GetArrayLength(inJNIArray);

    jint sum = 0;
    for(int i = 0; i < length; ++i) {
        sum += inArray[i];
    }

    jdouble average = (jdouble)sum / length;
    //释放数组
    env->ReleaseIntArrayElements(inJNIArray, inArray, 0); // release resource

    //构造返回数据
    jdouble outArray[] = {sum, average};
    jdoubleArray outJNIArray = env->NewDoubleArray(2);
    if(NULL == outJNIArray) return NULL;
    //向 jdoubleArray 写入数据
    env->SetDoubleArrayRegion(outJNIArray, 0, 2, outArray);
    return outJNIArray;
}
```

## 6. C层访问Java类的field

java 层：

```java
//成员变量
private int number = 88;
private String message = "Hello from Java";
//静态变量
private static double numberStatic = 1998.2;
//访问对象
private native void modifyVariable();
```

c 层：

```cpp
JNIEXPORT void JNICALL Java_HelloJNI_modifyVariable(JNIEnv *env, jobject obj) {
    //0.获取到 jcalss
    jclass thisClass = env->GetObjectClass(obj);
  
    //1.获取到 filed 的 ID
    jfieldID numberId = env->GetFieldID(thisClass, "number", "I");
    if (nullptr == numberId) {
        return;
    }
    //2.根据 id 获取到 filed 
    jint number = env->GetIntField(obj, numberId);
    cout << "In C++, the number from java is " << number << endl;

    //3.给 filed 赋值
    number = 99;
    env->SetIntField(obj, numberId, number);

    //获取一个 String 成员变量，与获取 number 类似
    jfieldID messageId = env->GetFieldID(thisClass, "message", "Ljava/lang/String;");
    if(NULL == messageId) return;

    jstring message =  (jstring)env->GetObjectField(obj, messageId);

    const char* str = env->GetStringUTFChars(message, NULL);
    if(NULL == str) return;

    cout << "In C++, the message is " << str << endl;
    //内存清理
    env->ReleaseStringUTFChars(message, str);

    message = env->NewStringUTF("Hello from C++");
    if(NULL == message) return;

    env->SetObjectField(obj, messageId, message);

    //访问静态变量
    jfieldID staticNumberId = env->GetStaticFieldID(thisClass, "numberStatic", "D");
    if (nullptr == staticNumberId) {
        return;
    }
    jdouble number2 = env->GetStaticDoubleField(thisClass, staticNumberId);
    cout << "In C++, the static double is " << number2 << endl;

    number2 = 77.88;
    env->SetStaticDoubleField(thisClass, fidStaticNumber, number2);

}

```

GetFieldID 的最后一个参数是字段描述符：

| **描述符**   | **含义** |
| ------------------ | -------------- |
| I                  | int            |
| B                  | byte           |
| S                  | short          |
| J                  | long           |
| F                  | float          |
| D                  | double         |
| C                  | char           |
| Z                  | boolean        |
| [I                 | int[]          |
| Ljava/lang/String  | String         |
| [Ljava/lang/String | String[]       |

## 7. C层调用Java层方法

java 层：

```java
public class TestJNICallBackMethod{
    static {
        System.loadLibrary("myjni");
    }

    private native void nativeMethod();

    private void callback(){
        System.out.println("In Java");
    }

    private void callback(String message){
        System.out.println("In Java with " + message);
    }

    private double callbackAverage(int n1, int n2){
        return ((double)n1 + n2) / 2.0;
    }

    private static String callbackStatic(){
        return "From static Java method";
    }

    public static void main(String[] args){
        new TestJNICallBackMethod().nativeMethod();
    }
}
```

cpp 层：

```cpp
#include "TestJNICallBackMethod.h"
#include <iostream>

using namespace std;

JNIEXPORT void JNICALL Java_TestJNICallBackMethod_nativeMethod(
    JNIEnv *env, jobject thisObj)
{
    jclass thisClass = env->GetObjectClass(thisObj);

    jmethodID midCallBack = env->GetMethodID(thisClass, "callback", "()V");
    if(NULL == midCallBack) return;
    cout << "In C++, call back Java's callback()\n";

    // Call back the method (which returns void), based on the Method ID
    env->CallVoidMethod(thisObj, midCallBack);

    jmethodID midCallBackStr = env->GetMethodID(thisClass, "callback", "(Ljava/lang/String;)V");
    if(NULL == midCallBackStr) return;
    cout << "In C++, call back Java's callback(String)\n";
    jstring message = env->NewStringUTF("Hello from C++");
    env->CallVoidMethod(thisObj, midCallBackStr, message);

    jmethodID midCallBackAverage = env->GetMethodID(thisClass, "callbackAverage", "(II)D");
    if(NULL == midCallBackAverage) return;
    jdouble average = env->CallDoubleMethod(thisObj, midCallBackAverage, 2, 3);
    cout << "In C++, the average is " << average << endl;

    jmethodID midCallBackStatic = env->GetStaticMethodID(thisClass, "callbackStatic", "()Ljava/lang/String;");
    if(NULL == midCallBackStatic) return;
    jstring resultJNIStr = (jstring)env->CallStaticObjectMethod(thisClass, midCallBackStatic);
    const char* resultStr = env->GetStringUTFChars(resultJNIStr, NULL);
    if(NULL == resultStr) return;
    cout << "In C++, the returned string is " << resultStr << endl;
    env->ReleaseStringUTFChars(resultJNIStr, resultStr);
}
```

## 参考资料

- [JNI 简明教程之手把手教你入门](https://blog.csdn.net/weiwei9363/article/details/97886291)
- [cross-compiling-for-android-with-the-ndk](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-android-with-the-ndk)
- [Android 官方cmake文档](https://developer.android.com/ndk/guides/cmake)
- 《Android C++高级编程》第三章
- [JNI/NDK开发指南](https://blog.csdn.net/xyang81/category_9263427.html)
